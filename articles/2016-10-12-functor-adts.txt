package[value="articles"]{}

post[id=functor-adts,date=2016-10-12,description="Using contravariance, type parameters and type members to implement a functor in ADTs",Implementing functors in ADTs] {
  section[Motivation] {
    It is a common problem to define url[https://en.wikipedia.org/wiki/Algebraic_data_type]{Algebraic Data Types} (ADTs). To prevent duplication, shared functionality should be ideally kept in base code{trait}s. Oftentimes, a problem arises that in the base code{trait} we do not know the child type the function is called on.

    In other words, we want to be able to implement operations such as code{map()} in terms of a functor:
    scala[type=section,file=FunctorAdts,value=functor]{}

    In this article, I am going to outline different ways how to solve this particular problem in Scala.
  }

  section[Contravariance] {
    Consider a simple binary tree:
    scala[type=section,file=FunctorAdts,value=bin-tree]{}

    We are going to leverage the fact that functions are contravariant in their return types. Let us extend our ADT by a code{map()} function:
    scala[type=section,file=FunctorAdts,value=bin-tree-map]{}

     In the base code{trait} we defined the function prototype, and overrode this function with the return types of the actual child classes. Thanks to contravariance code{map()} returns code{Leaf} or code{Branch}, respectively.
  }

  section[Type parameters] {
    What if our ADT is a little more complicated and has several nested branch types with shared functionality? Let us consider a type-safe representation of HTML, where tags like code{div} and code{b} are represented as separate types:
    scala[type=section,file=FunctorAdts,value=html-tree]{}

    We defined a code{trait Tag} that defines functions available on all tag nodes. Hereby, we can keep our tag classes succinct. But it comes at the price that the return type of code{copy()} does not get "propagated" to code{map()}. Therefore, code{map()} returns code{Tag} when called on any tag node.

    As in our example where we provide tag-specific attributes, this turns out to be a severe limitation. For example, code{id} could not be accessed in this example on the return value of code{map}.

    To remedy that our type signature does not exhibit the same type signature of a functor, we could attempt to solve it by adding a type parameter to the base code{trait}:
    scala[type=section,file=FunctorAdts,value=type-param]{}

    While it works as expected, you see that our solution got unwieldy, requiring many wildcards and even type casts.
  }

  section[Type members] {
    Luckily, Scala provides us with code{type} members a better alternative:
    scala[type=section,file=FunctorAdts,value=type-member]{}

    It still works the same, but is a much more elegant solution than type parameters.

    One caveat: We cannot override type code{T} in code{Tag} with a concrete type, otherwise the return type of code{copy()} and code{map} will be fixed and cannot be changed in child classes. However, we can refine the type constraint on code{T}, which is what we have done in our solution with code{override type T <: Tag}.
  }

  section[Examples] {
    We used the same technique in MetaWeb to provide type-safe bindings for HTML. See url[https://github.com/MetaStack-pl/MetaWeb/blob/master/core/shared/src/main/scala/pl/metastack/metaweb/tree/Node.scala]{this file} for our tree implementation.
  }

  section[Conclusion] {
    We have seen a couple of ways to implement functors in ADTs. Whenever possible, try to make use of Scala's contravariance property. If your ADT is more complicated than that, type parameters are the preferred solution.

    In a follow-up article, I am going to talk about path-dependent types and motivate them with real-world scenarios.
  }
}
